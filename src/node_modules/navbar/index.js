const icon_button = require('buttons/icon_button')
const logo_button = require('buttons/logo_button')
const text_button = require('buttons/text_button')
const path = require('path')

const cwd = process.cwd()
const prefix = path.relative(cwd, __dirname)

const sheet = new CSSStyleSheet()

sheet.replaceSync(get_theme())
/******************************************************************************
NAVBAR COMPONENT
******************************************************************************/
var count = 0
const ID = __filename
const STATE = { ids: {}, hub: {} } // all state of component module
// ----------------------------------------
const default_opts = { page: 'HOME' }

module.exports = navbar

function navbar (opts = default_opts, protocol) {
  // ----------------------------------------
  // INSTANCE STATE & ID
  const id = `${ID}:${count++}` // assigns their own name
  const state = STATE.ids[id] = { status: {}, wait: {}, hub: {}, aka: {} } // all state of component instance
  // ----------------------------------------
  const on = { 'theme': handle_active_change }
  // ----------------------------------------
  const send = protocol(Object.assign(listen, { id }))
  state.hub[send.id] = { mid: 0, send, on } // store channel
  state.aka.up = send.id
  function invalid (message) { console.error('invalid type', message) }
  function listen (message) {
    console.log(`[${id}]`, message)
    const { on } = state.hub[state.aka.up] // @TODO: from `to`
    const action = on[message.type] || invalid
    action(message)
  }
  // @TODO: how to disconnect channel
  // ----------------------------------------
  // OPTS
  // ----------------------------------------
  const { data, page = default_opts.page } = opts
  // Assigning all the icons
  const {
    icon_consortium,
    icon_blogger,
    icon_discord,
    icon_twitter,
    icon_github,
    icon_terminal,
    icon_theme,
    icon_arrow_down,
    icon_arrow_up
  } = data.img_src
  // ----------------------------------------
  // TEMPLATE
  // ----------------------------------------
  const el = document.createElement('div')
  const shadow = el.attachShadow({ mode: 'closed' })
  shadow.innerHTML = `<div class="navbar_wrapper">
    <div class="navbar">
        <div class="nav_toggle_wrapper">
          <div class="logo_button_wrapper"></div>
          <div class="nav_toggle"></div>
        </div>
        <div class="page_btns_wrapper"></div>
        <div class="icon_btn_wrapper"></div>
    </div>
  </div>`
  // sm nav buttons
  const consortium_btn = icon_button({ src: icon_consortium }, navigation_protocol('CONSORTIUM'))
  const logo_btn = logo_button()
  const nav_toggle_wrapper = shadow.querySelector('.nav_toggle_wrapper')
  const logo_button_wrapper = shadow.querySelector('.logo_button_wrapper')
  nav_toggle_wrapper.prepend(consortium_btn)
  logo_button_wrapper.append(logo_btn)
  // adding nav toggle button
  const nav_toggle_btn = icon_button({ src: icon_arrow_down, src_active: icon_arrow_up })
  const nav_toggle = shadow.querySelector('.nav_toggle')
  nav_toggle.append(nav_toggle_btn)
  nav_toggle.onclick = event => shadow.querySelector('.navbar').classList.toggle('active')
  // Page List Buttons
  const text_btns = [
    { element: text_button({ text: 'HOME' }, navigation_protocol('HOME')) },
    { element: text_button({ text: 'PROJECTS' }, navigation_protocol('PROJECTS')) },
    { element: text_button({ text: 'GROWTH PROGRAM' }, navigation_protocol('GROWTH PROGRAM')) },
    { element: text_button({ text: 'TIMELINE' }, navigation_protocol('TIMELINE')) }
  ]
  const page_btns_wrapper = shadow.querySelector('.page_btns_wrapper')
  text_btns.forEach(button_data => {
    const text_button_wrapper = document.createElement('div')
    text_button_wrapper.classList.add('text_button_wrapper')
    text_button_wrapper.appendChild(button_data.element)
    page_btns_wrapper.appendChild(text_button_wrapper)
  })
  // Adding social and action buttons
  const icon_btns = [
    { element: icon_button({ src: icon_blogger }) },
    { element: icon_button({ src: icon_discord }) },
    { element: icon_button({ src: icon_twitter }) },
    { element: icon_button({ src: icon_github }) },
    { element: icon_button({ src: icon_terminal }), type: 'toggle_terminal' },
  ]
  icon_btns.forEach(icon_btn => {
    if(icon_btn.type) icon_btn.element.onclick = e => {
      const [by, to, mid] = [id, 'page', 0]
      send({
        head: [by, to, mid],
        type: 'toggle_terminal',
      })
    }
  })
  const theme_btn = icon_button({ src: icon_theme })
  theme_btn.onclick = e => {
    const head = { from: id, to: 'page', mid: 0 }
    send({ head, type:'handle_theme_change', data: '' })
  }
  const icon_btn_wrapper = shadow.querySelector('.icon_btn_wrapper')
  icon_btn_wrapper.append(...icon_btns.map(button_data => button_data.element), theme_btn)
  shadow.adoptedStyleSheets = [sheet]
  // ----------------------------------------
  // INIT
  // ----------------------------------------
  initialize(page)

  return el

  function initialize (page) {
    // SET DEFAULTS
    state.status.active_button = state.aka[page]
    const active_id = state.status.active_button
    const be_channel = state.hub[active_id]
    const up_channel = state.hub[state.aka.up]

    // APPLY OPTS (1):
    // @TODO: issue: how to submit an `onclick` event to trigger the initial change?

    const [by, to, mid] = [id, id, 0]
    let message = { head: [by, to, mid], type: 'init' }
    do_page_change(page, message.head, { be_channel, up_channel })
  }
  function handle_active_change (message) { // handle on
    const { data: active_page } = message

    console.log('INITIALIZE', {active_page, active_id: state.aka[active_page] })

    state.status.active_button = state.aka[active_page]
    // APPLY OPTS (2):
    // @TODO: PROBLEM: this makes navbar know what is active, but it doesnt highlight it yet
  }
  // protocol
  function theme_button_protocol (handshake, notify, mid = 0) {

  }
  function navigation_protocol (petname) {
    return function protocol (notify, mid = 0) {
      const on = { 'click': onclick }
      state.hub[notify.id] = { mid: 0, send: notify, on }
      state.aka[petname] = notify.id
      return Object.assign(listen, { id })
      // APPLY OPTS (3):
      // @INFO: onclick is for later
      // @TODO: but init should set itself active -> apply OPTS
      // => (e.g. page === petname): trigger active + trigger parent to show content
      // ALSO: opts should be "asked for" instead
      // ALSO: take care of problems of order in which things get applied synchronously... test for it!       
      function invalid (message) { console.error('invalid type', message) }
      function listen (message) {
        console.log(`[${id}]`, message)
        const { on } = state.hub[state.aka[petname]]
        const action = on[message.type] || invalid
        action(message)
      }
      function onclick (message) { // receive click from a button -> that button will become active!
        const active_id = state.status.active_button
        const default_id = state.aka[page] // only exists because it got initialized first (timing issue?)
        if (active_id === notify.id && active_id === default_id) return // means default is already active
        // @TODO: maybe change logic to be able to toggle an "empty desktop" too?
        const [
          next_id, data
        ] = active_id === notify.id ? [default_id, page] : [notify.id, petname]
        const be_channel = state.hub[next_id]
        const ex_channel = state.hub[active_id] // active button
        const up_channel = state.hub[state.aka.up] // parent element
        do_page_change(data, message.head, { be_channel, ex_channel, up_channel })
      }
    }
  }
  function do_page_change (page, head, { be_channel, ex_channel, up_channel }) {
    if (be_channel) be_channel.send({ // new active nav button
      head: [id, be_channel.send.id, be_channel.mid++],
      refs: { cause: head },
      type: 'activate',
    })
    if (ex_channel) ex_channel.send({ // old active nav button
      head: [id, ex_channel.send.id, ex_channel.mid++],
      refs: { cause: head },
      type: 'inactivate',
    })
    if (up_channel) up_channel.send({ // notify parent to update page content
      head: [id, up_channel.send.id, up_channel.mid++],
      refs: { cause: head },
      type: 'handle_page_change',
      data: page
    })
    state.status.active_button = be_channel.send.id
  }
}
function get_theme () {
  return`
    .navbar_wrapper {
      container-type: inline-size;
      width: 100%;
    }
    .navbar {
      display: block;
      width: 100%;
      height: 40px;
      overflow: hidden;
      border-bottom: 1px solid var(--primary_color);
      --s: 15px; /* control the size */
      --_g: var(--bg_color) /* first color */ 0 25%, #0000 0 50%;
      background:
        repeating-conic-gradient(at 33% 33%,var(--_g)),
        repeating-conic-gradient(at 66% 66%,var(--_g)),
        var(--primary_color);  /* second color */
      background-size: var(--s) var(--s);
    }
    .navbar.active {
      height: max-content;
    }
    /* Starting buttons wrapper */
    .nav_toggle_wrapper {
      display: flex;
      width: 100%;
      justify-content: stretch;
    }
    .nav_toggle_wrapper .logo_button_wrapper {
      width: 100% !important;
      flex-grow: 1;
    }
    .nav_toggle {
      display: block;
    }
    .page_btns_wrapper {
      width: 100%;
      display: flex;
      flex-direction: column;
    }
    .page_btns_wrapper .text_button_wrapper{
      width: 100%;
      flex-grow: 1;
    }
    .icon_btn_wrapper {
      display: flex;
      justify-content: flex-start;
    }
    .page_list {
      display: none;
    }
    @container (min-width: 899px) {
      .navbar {
        display: flex;
      }
      .nav_toggle_wrapper {
        width: max-content;
        display: flex;
      }
      .nav_toggle_wrapper .logo_button_wrapper {
        width: max-content !important;
      }
      .nav_toggle {
        display: none;
      }
      .page_list {
        display: flex;
      }
      .nav_toggle_wrapper .nav_toggle_btn {
        display: none;
      }
      .page_btns_wrapper {
        flex-direction: row;
      }
      .page_btns_wrapper .text_button_wrapper {
        width: max-content !important;
        flex-grow: unset;
      }
    }
    .socials_list {
      display: flex;
    }
  `
}