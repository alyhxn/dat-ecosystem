module.exports = app_timeline_mini


const path = require('path')
const cwd = process.cwd()
const prefix = path.relative(cwd, __dirname)

const window_bar = require('window_bar')
const timeline_card = require('timeline_card')
const timeline_filter = require('timeline_filter')
const year_filter = require('year_filter')
const month_filter = require('month_filter')
const scrollbar = require('scrollbar')

// CSS Boiler Plat
const sheet = new CSSStyleSheet
const theme = get_theme()
sheet.replaceSync(theme)


let id = 0;

function app_timeline_mini (opts, protocol) {

    const name = `app_timeline_mini-${id++}`
    const {data} = opts
    const PROTOCOL = {
        YEAR: '',
        MONTH: '',
        DATE: '',
        updateCalendar,
    }
    // Assigning all the icons
    const { img_src: {
        icon_folder= `${prefix}/icon_folder.svg`,
    } } = data

    const el = document.createElement('div')
    const shadow = el.attachShadow ( { mode : 'closed' } )

    shadow.innerHTML = `
        <div class="main_wrapper">
            <div class="filter_wrapper">
                <div class="month_wrapper">
                    <div class="scrollbar_wrapper">
                        <div class="timeline_wrapper"></div>
                    </div>
                </div>
            </div>
        </div>
        <style> ${get_theme} </style>
    `

    // Adding Applicatin window Bar
    const cover_window = window_bar({
        name:'TIMELINE', 
        src: icon_folder,
        data: data
    }, app_timeline_protocol)


    // Adding timeline cards
    const timeline_wrapper = shadow.querySelector('.timeline_wrapper')
    const cards_data = [
        { title: 'Official starting of the web course.', date: 'July 11, 2022', time: '07:05AM', link: '/', desc: 'The course is called - vanilla.js hyper modular web component building course and it will last approximately 4-8 weeks.. ', tags: ['Hypercore', 'Hypercore', 'Hypercore'], data: data, active_state: 'ACTIVE'
        },{ title: 'Official starting of the web course.', date: 'May 11, 2022', time: '07:05AM', link: '/', desc: 'The course is called - vanilla.js hyper modular web component building course and it will last approximately 4-8 weeks.. ', tags: ['Hypercore', 'Hypercore', 'Hypercore'], data: data, active_state: 'ACTIVE'
        },{ title: 'Official starting of the web course.', date: 'March 11, 2022', time: '07:05AM', link: '/', desc: 'The course is called - vanilla.js hyper modular web component building course and it will last approximately 4-8 weeks.. ', tags: ['Hypercore', 'Hypercore', 'Hypercore'], data: data, active_state: 'ACTIVE'
        },{ title: 'Official starting of the web course.', date: 'March 11, 2022', time: '07:05AM', link: '/', desc: 'The course is called - vanilla.js hyper modular web component building course and it will last approximately 4-8 weeks.. ', tags: ['Hypercore', 'Hypercore', 'Hypercore'], data: data, active_state: 'UNACTIVE'
        },{ title: 'Official starting of the web course.', date: 'March 11, 2021', time: '07:05AM', link: '/', desc: 'The course is called - vanilla.js hyper modular web component building course and it will last approximately 4-8 weeks.. ', tags: ['Hypercore', 'Hypercore', 'Hypercore'], data: data, active_state: 'UNACTIVE'
        },{ title: 'Official starting of the web course.', date: 'July 11, 2021', time: '07:05AM', link: '/', desc: 'The course is called - vanilla.js hyper modular web component building course and it will last approximately 4-8 weeks.. ', tags: ['Hypercore', 'Hypercore', 'Hypercore'], data: data, active_state: 'UNACTIVE'
        },{ title: 'Official starting of the web course.', date: 'April 11, 2021', time: '07:05AM', link: '/', desc: 'The course is called - vanilla.js hyper modular web component building course and it will last approximately 4-8 weeks.. ', tags: ['Hypercore', 'Hypercore', 'Hypercore'], data: data, active_state: 'UNACTIVE'
        },{ title: 'Official starting of the web course.', date: 'July 11, 2022', time: '07:05AM', link: '/', desc: 'The course is called - vanilla.js hyper modular web component building course and it will last approximately 4-8 weeks.. ', tags: ['Hypercore', 'Hypercore', 'Hypercore'], data: data, active_state: 'PAUSED'
        },{ title: 'Official starting of the web course.', date: 'April 11, 2023', time: '07:05AM', link: '/', desc: 'The course is called - vanilla.js hyper modular web component building course and it will last approximately 4-8 weeks.. ', tags: ['Hypercore', 'Hypercore', 'Hypercore'], data: data, active_state: 'PAUSED'
        },{ title: 'Official starting of the web course.', date: 'July 11, 2023', time: '07:05AM', link: '/', desc: 'The course is called - vanilla.js hyper modular web component building course and it will last approximately 4-8 weeks.. ', tags: ['Hypercore', 'Hypercore', 'Hypercore'], data: data, active_state: 'PAUSED'
        },
    ]

    const tags = new Set()
    // let latest_date = new Date(0);
    cards_data.forEach(card_data => {
        card_data.tags.forEach(tag => tags.add(tag))
        // const date = new Date(card_data.date)
        // if(date > latest_date){
        //     latest_date = date
        // }
    })
    // const month = latest_date.toLocaleString('default', { month: 'long' });
    // const year = latest_date.getFullYear()

    const timeline_cards = cards_data.map((card_data) => timeline_card(card_data))
    timeline_cards.forEach((card) => {
        timeline_wrapper.append(card)
    })

    const main_wrapper = shadow.querySelector('.main_wrapper')
    
    main_wrapper.append(timeline_filter({data, tags: Array.from(tags)}, app_timeline_protocol))

    const filter_wrapper = shadow.querySelector('.filter_wrapper')
    const year_filter_wrapper = year_filter({data}, app_timeline_protocol)

    const month_wrapper = shadow.querySelector('.month_wrapper')
    const month_filter_wrapper = month_filter({data}, app_timeline_protocol)

    const scrollbar_wrapper = shadow.querySelector('.scrollbar_wrapper')
    scrollbar_wrapper.append(scrollbar({data: data}, app_timeline_protocol))

    shadow.adoptedStyleSheets = [ sheet ]
    shadow.prepend(cover_window)
    return el



    
    //Setting protocols
    function app_timeline_protocol(handshake, send){
        if(handshake.from.includes('scrollbar')){
            const ro = new ResizeObserver(entries => send[0]());
            ro.observe(scrollbar_wrapper);
            timeline_wrapper.onscroll = send[0]
            PROTOCOL['handleScroll'] = send[0]
            PROTOCOL['getScrollInfo'] = send[1]
            return [listen, setScrollTop]
        }
        else if(handshake.from.includes('window_bar')){
            PROTOCOL['toggle_active_state'] = toggle_active_state
        }
        else if(handshake.from.includes('timeline_filter')){
            PROTOCOL['setFilter'] = setFilter
            PROTOCOL['toggle_month_filter'] = toggle_month_filter
            PROTOCOL['toggle_year_filter'] = toggle_year_filter
            PROTOCOL['get_date'] = send
        }
        else if(handshake.from.includes('year_filter')){
            PROTOCOL['setFilter'] = setFilter
        }
        else if(handshake.from.includes('month_filter')){
            PROTOCOL['setFilter'] = setFilter
            PROTOCOL['month_filter'] = send
        }
        return listen
        function listen (message){
            const {head, type, data} = message
            const {by, to, mid} = head
            // if( to !== name) return console.error('address unknown', message)
            if(by.includes('scrollbar'))
            {
                message.data = {sh: timeline_wrapper.scrollHeight, ch: timeline_wrapper.clientHeight, st: timeline_wrapper.scrollTop}
                PROTOCOL.getScrollInfo(message)
            }
            else if(by.includes('timeline_filter') || by.includes('month_filter')){
                PROTOCOL[type](data)
            }
            else if(by.includes('year_filter')){
                PROTOCOL[type](data)
                PROTOCOL.updateCalendar()
            }
            else if(by.includes('window_bar')){
                PROTOCOL[type](message)
            }
        }
        
        async function setScrollTop(value){
            timeline_wrapper.scrollTop = value
        }
        async function setFilter(data){
            PROTOCOL[data.filter] = data.value

            timeline_wrapper.innerHTML = ''
            let cardfilter = [...cards_data]

            if(PROTOCOL.SEARCH)
                cardfilter = cardfilter.filter((card_data) => {return card_data.title.toLowerCase().match(PROTOCOL.SEARCH.toLowerCase())})

            if(PROTOCOL.STATUS && PROTOCOL.STATUS !== 'NULL')
                cardfilter = cardfilter.filter((card_data) => {return card_data.active_state === PROTOCOL.STATUS && card_data })

            if(PROTOCOL.TAGS && PROTOCOL.TAGS !== 'NULL')
                cardfilter = cardfilter.filter((card_data) => {return card_data.tags.includes(PROTOCOL.TAGS) && card_data })
            
            if(PROTOCOL.YEAR)
                cardfilter = cardfilter.filter((card_data) => {return card_data.date.toLowerCase().match(PROTOCOL.YEAR.toLowerCase())})

            if(PROTOCOL.MONTH)
                cardfilter = cardfilter.filter((card_data) => {return card_data.date.toLowerCase().match(PROTOCOL.MONTH.toLowerCase())})

            if(PROTOCOL.DATE)
            cardfilter = cardfilter.filter((card_data) => {return card_data.date.toLowerCase().match(PROTOCOL.DATE.toLowerCase())})
            

            const timeline_cards = cardfilter.map((card_data) => timeline_card(card_data))
                timeline_cards.forEach((card) => {
                    timeline_wrapper.append(card)
            })
            PROTOCOL['handleScroll']()
            PROTOCOL['get_date']({
                    head: {by:name, to:'timeline_filter', mid:0},
                    type: null,
                    data: {month: PROTOCOL.MONTH , year: PROTOCOL.YEAR}
            })
        }
        async function toggle_active_state (message) {
            const {head, refs, type, data, meta} = message
            const {active_state} = data
            ;( active_state === 'active')?el.style.display = 'none':''
        }
        async function toggle_month_filter (message) {
            if(month_wrapper.contains(month_filter_wrapper))
                month_wrapper.removeChild(month_filter_wrapper)
            else
                month_wrapper.append(month_filter_wrapper)
        }
        async function toggle_year_filter (message) {
            if(filter_wrapper.contains(year_filter_wrapper))
                filter_wrapper.removeChild(year_filter_wrapper)
            else
                filter_wrapper.append(year_filter_wrapper)
        }
        }
    async function updateCalendar (){
        let dates = []
        if(PROTOCOL.YEAR)
            cards_data.forEach(card_data => {
                if(card_data.date.includes(PROTOCOL.YEAR)){
                    dates.push(card_data.date)
                }
            })
        PROTOCOL.month_filter({
            head: {by:name, to:'month_filter', mid:0},
            type: null,
            data: dates
    })
    }
}




function get_theme(){
    return`
        *{
            box-sizing: border-box;
        }
        .main_wrapper{
            display: flex;
            flex-direction: column;
            container-type: inline-size;
            width: 100%;
            height: 100%;
            margin-bottom: 30px;
        }
        .filter_wrapper{
            display: flex;
            width: 100%;
            height: 100%;
        }
        .scrollbar_wrapper{
            display: flex;
            width: 100%;
            height: 100%;
        }
        .month_wrapper{
            width:100%;
            height: 100%;
            overflow: hidden;
            border: 1px solid var(--primary_color);
        }
        .timeline_wrapper{
            --s: 20px; /* control the size */
            --_g: var(--bg_color) /* first color */ 0 25%, #0000 0 50%;
            background:
                repeating-conic-gradient(at 66% 66%,var(--_g)),
                repeating-conic-gradient(at 33% 33%,var(--_g)),
                var(--primary_color);  /* second color */ 
            background-size: var(--s) var(--s);  
            overflow: scroll;
            scrollbar-width: none; /* For Firefox */
            border:1px solid var(--primary_color);
            width:100%;
            height: 400px;
            padding: 0px;
            display: grid;
            gap:20px;
            grid-template-columns: 12fr;
        }
        .timeline_wrapper::-webkit-scrollbar {
            display: none;
        }
        @container(min-width: 768px) {
            .timeline_wrapper{
                grid-template-columns: repeat(2, 6fr);
            }
        }
    
        @container(min-width: 1200px) {
            .timeline_wrapper{
                grid-template-columns: repeat(3, 4fr);
            }
        }
          
        /*---------- Mobile devices ----------*/
        @media (min-width: 480px) {
        }

        /*---------- iPads, Tablets ----------*/
        @media (min-width: 768px) {
        }

        /*---------- Mediuem screens, laptops ----------*/
        @media (min-width: 1024px) {}
    `
}