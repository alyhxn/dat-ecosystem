const window_bar = require('window-bar')
const timeline_card = require('timeline-card')
const timeline_filter = require('timeline-filter')
const year_filter = require('year-filter')
const month_filter = require('month-filter')
const scrollbar = require('scrollbar')

const sheet = new CSSStyleSheet
sheet.replaceSync(get_theme())
/******************************************************************************
  APP TIMELINE COMPONENT
******************************************************************************/
// ----------------------------------------
// MODULE STATE & ID
var count = 0
const [cwd, dir] = [process.cwd(), __filename].map(x => new URL(x, 'file://').href)
const ID = dir.slice(cwd.length)
const STATE = { ids: {}, net: {} } // all state of component module
// ----------------------------------------
const default_opts = { }

module.exports = app_timeline

function app_timeline (opts = default_opts, protocol) {
  // ----------------------------------------
  // ID + JSON STATE
  // ----------------------------------------
  const name = `app_timeline-${count++}`
  // ----------------------------------------
  // OPTS
  // ----------------------------------------
  const {data} = opts
  // Assigning all the icons
  const { img_src: {
      icon_folder= `${prefix}/icon_folder.svg`,
  } } = data
  // ----------------------------------------
  // PROTOCOL
  // ----------------------------------------
  const PROTOCOL = {
    YEAR: '',
    MONTH: '',
    DATE: '',
    updateCalendar,
  }
  // ----------------------------------------
  // TEMPLATE
  // ----------------------------------------
  const el = document.createElement('div')
  const shadow = el.attachShadow ({ mode : 'closed' })
  shadow.innerHTML = `<div class="main_wrapper">
    <div class="filter_wrapper">
      <div class="month_wrapper">
        <div class="scrollbar_wrapper">
          <div class="timeline_wrapper"></div>
        </div>
      </div>
    </div>
  </div>`
  shadow.adoptedStyleSheets = [sheet]
  const main_wrapper = shadow.querySelector('.main_wrapper')
  const timeline_wrapper = shadow.querySelector('.timeline_wrapper')
  const filter_wrapper = shadow.querySelector('.filter_wrapper')
  const month_wrapper = shadow.querySelector('.month_wrapper')
  const scrollbar_wrapper = shadow.querySelector('.scrollbar_wrapper')
  // ----------------------------------------
  // ELEMENTS
  // ----------------------------------------
  // Adding Applicatin window Bar
  const cover_window = window_bar({
    name:'TIMELINE', 
    src: icon_folder,
    data: data
  }, app_timeline_protocol)
  // Adding timeline cards
  const cards_data = [{
    title: 'Official starting of the web course.', date: 'July 11, 2022', time: '07:05AM', link: '/', desc: 'The course is called - vanilla.js hyper modular web component building course and it will last approximately 4-8 weeks.. ', tags: ['Hypercore', 'Hypercore', 'Hypercore'], data, active_state: 'ACTIVE'
  },{
    title: 'Official starting of the web course.', date: 'May 11, 2022', time: '07:05AM', link: '/', desc: 'The course is called - vanilla.js hyper modular web component building course and it will last approximately 4-8 weeks.. ', tags: ['Hypercore', 'Hypercore', 'Hypercore'], data, active_state: 'ACTIVE'
  },{
    title: 'Official starting of the web course.', date: 'March 11, 2022', time: '07:05AM', link: '/', desc: 'The course is called - vanilla.js hyper modular web component building course and it will last approximately 4-8 weeks.. ', tags: ['Hypercore', 'Hypercore', 'Hypercore'], data, active_state: 'ACTIVE'
  },{
    title: 'Official starting of the web course.', date: 'March 11, 2022', time: '07:05AM', link: '/', desc: 'The course is called - vanilla.js hyper modular web component building course and it will last approximately 4-8 weeks.. ', tags: ['Hypercore', 'Hypercore', 'Hypercore'], data, active_state: 'UNACTIVE'
  },{
    title: 'Official starting of the web course.', date: 'March 11, 2021', time: '07:05AM', link: '/', desc: 'The course is called - vanilla.js hyper modular web component building course and it will last approximately 4-8 weeks.. ', tags: ['Hypercore', 'Hypercore', 'Hypercore'], data, active_state: 'UNACTIVE'
  },{
    title: 'Official starting of the web course.', date: 'July 11, 2021', time: '07:05AM', link: '/', desc: 'The course is called - vanilla.js hyper modular web component building course and it will last approximately 4-8 weeks.. ', tags: ['Hypercore', 'Hypercore', 'Hypercore'], data, active_state: 'UNACTIVE'
  },{
    title: 'Official starting of the web course.', date: 'April 11, 2021', time: '07:05AM', link: '/', desc: 'The course is called - vanilla.js hyper modular web component building course and it will last approximately 4-8 weeks.. ', tags: ['Hypercore', 'Hypercore', 'Hypercore'], data, active_state: 'UNACTIVE'
  },{
    title: 'Official starting of the web course.', date: 'July 11, 2022', time: '07:05AM', link: '/', desc: 'The course is called - vanilla.js hyper modular web component building course and it will last approximately 4-8 weeks.. ', tags: ['Hypercore', 'Hypercore', 'Hypercore'], data, active_state: 'PAUSED'
  },{
    title: 'Official starting of the web course.', date: 'April 11, 2023', time: '07:05AM', link: '/', desc: 'The course is called - vanilla.js hyper modular web component building course and it will last approximately 4-8 weeks.. ', tags: ['Hypercore', 'Hypercore', 'Hypercore'], data, active_state: 'PAUSED'
  },{
    title: 'Official starting of the web course.', date: 'July 11, 2023', time: '07:05AM', link: '/', desc: 'The course is called - vanilla.js hyper modular web component building course and it will last approximately 4-8 weeks.. ', tags: ['Hypercore', 'Hypercore', 'Hypercore'], data, active_state: 'PAUSED'
  }]
  const tags = new Set()
  const new_cards_data = []
  const card_groups = []
  let year_cache, card_group
  cards_data.forEach((card_data, i) => {
    card_data.tags.forEach(tag => tags.add(tag))
    const date = new Date(card_data.date + ' ' + convert_time_format(card_data.time))
    card_data = {...card_data, date_raw: date.getTime()}
    cards_data[i] = card_data
  })
  cards_data.sort(function (a, b) { return  b.date_raw - a.date_raw })
  PROTOCOL.YEAR = new Date(cards_data[0].date_raw).getFullYear()
  const timeline_cards = cards_data.map((card_data) => {
    const card = timeline_card(card_data)
    const slice = cards_data[card.id.slice(-1)].date.slice(-4)
    if (year_cache !== slice) {
      card_group = document.createElement('div')
      card_group.classList.add('card_group')
      card_groups.push(card_group)
      year_cache = slice
    }
    card_group.append(card)
    return card
  })
  timeline_wrapper.append(...card_groups)
  main_wrapper.append(timeline_filter({
    data, tags: Array.from(tags),
    latest_date: cards_data[0].date_raw
  }, app_timeline_protocol))
  const year_filter_wrapper = year_filter({
    data, latest_date: cards_data[0].date_raw
  }, app_timeline_protocol)
  const month_filter_wrapper = month_filter({ data }, app_timeline_protocol)
  opts.data.img_src.icon_arrow_start = opts.data.img_src.icon_arrow_up
  opts.data.img_src.icon_arrow_end = opts.data.img_src.icon_arrow_down
  scrollbar_wrapper.append(scrollbar({ data }, app_timeline_protocol))
  timeline_wrapper.onscroll = () => {
    PROTOCOL.scrollbar({ type: 'handle_scroll' })
    const parent_top = timeline_wrapper.getBoundingClientRect().top
    timeline_cards.some(card => {
      const child_top = card.getBoundingClientRect().top
      if (child_top >= parent_top -100 && child_top < parent_top + 200) {
        const year = cards_data[card.id.slice(-1)].date.slice(-4)
        PROTOCOL.YEAR = year
        PROTOCOL.updateCalendar()
        PROTOCOL['year_filter']({
          head: { by: name, to: 'year_filter', mid: 0 },
          type: null,
          data: year
        })
        return true
      }
    })
    PROTOCOL['get_date']({
      head: { by:name, to: 'timeline_filter', mid: 0 },
      type: null,
      data: { month: PROTOCOL.MONTH , year: PROTOCOL.YEAR }
    })
  }
  shadow.prepend(cover_window)
  // ----------------------------------------
  // INIT
  // ----------------------------------------
  updateCalendar()

  return el
    
  function convert_time_format (time) {
    let temp = time.slice(0,2)
    if (time.includes('PM')) { temp = parseInt(temp) + 12 }
    return temp + time.slice(2, -2)
  }
  //Setting protocols
  function app_timeline_protocol (handshake, send) {
    if (!send) {
      send = handshake
      handshake = { from: send.id }
    }
    if (handshake.from.includes('scrollbar')) {


      const ro = new ResizeObserver(entries => send({ type: 'handle_scroll' }))
      ro.observe(scrollbar_wrapper)
      PROTOCOL.scrollbar = send

      return listen
    }
    else if (handshake.from.includes('window_bar')) {
      PROTOCOL['toggle_active_state'] = toggle_active_state
    }
    else if (handshake.from.includes('timeline_filter')) {
      PROTOCOL['setFilter'] = setFilter
      PROTOCOL['toggle_month_filter'] = toggle_month_filter
      PROTOCOL['toggle_year_filter'] = toggle_year_filter
      PROTOCOL['get_date'] = send
    }
    else if (handshake.from.includes('year_filter')) {
      PROTOCOL['setScroll'] = setScroll
      PROTOCOL['year_filter'] = send
    }
    else if (handshake.from.includes('month_filter')) {
      PROTOCOL['setFilter'] = setFilter
      PROTOCOL['month_filter'] = send
    }

    return listen

    function listen (message) {
      const { head,  refs, type, data, meta } = message
      const { by, to, mid } = head
      // if( to !== name) return console.error('address unknown', message)
      if (by.includes('scrollbar')) {
          if (message.type === 'set_scroll_start') return setScrollTop(message.data)
          message.type = 'update_size'
          message.data = {sh: timeline_wrapper.scrollHeight, ch: timeline_wrapper.clientHeight, st: timeline_wrapper.scrollTop}
          PROTOCOL.scrollbar(message)
      }
      else if (by.includes('timeline_filter') || by.includes('month_filter')) {
        PROTOCOL[type](data)
      }
      else if (by.includes('year_filter')) {
        PROTOCOL[type](data)
        PROTOCOL.updateCalendar()
      }
      else if (by.includes('window_bar')) {
        PROTOCOL[type](message)
      }
    }
    async function setScroll (data) {
      PROTOCOL[data.filter] = data.value
      timeline_cards.some(card => {
        const card_date = cards_data[card.id.slice(-1)].date
        if( card_date.includes(data.value) && card_date.includes(PROTOCOL.YEAR)) {
          setScrollTop(card.getBoundingClientRect().top - timeline_wrapper.getBoundingClientRect().top + timeline_wrapper.scrollTop)
          return true
        }
      })
      PROTOCOL['get_date']({
        head: { by: name, to: 'timeline_filter', mid: 0 },
        type: null,
        data: { month: PROTOCOL.MONTH , year: PROTOCOL.YEAR }
      })
      PROTOCOL['year_filter']({
        head:  {by: name, to: 'year_filter', mid: 0 },
        type: null,
        data: PROTOCOL.YEAR
      })
    }
    async function setScrollTop (value) {
      timeline_wrapper.scrollTop = value
    }
    async function setFilter(data){
      PROTOCOL[data.filter] = data.value
      timeline_wrapper.innerHTML = ''
      let cardfilter = [...cards_data]
      if (PROTOCOL.SEARCH) cardfilter = cardfilter.filter((card_data) => {
        return card_data.title.toLowerCase().match(PROTOCOL.SEARCH.toLowerCase())
      })
      if (PROTOCOL.STATUS && PROTOCOL.STATUS !== 'NULL') cardfilter = cardfilter.filter((card_data) => {
        return card_data.active_state === PROTOCOL.STATUS && card_data
      })
      if (PROTOCOL.TAGS && PROTOCOL.TAGS !== 'NULL') {
        cardfilter = cardfilter.filter((card_data) => {
          return card_data.tags.includes(PROTOCOL.TAGS) && card_data
        })
      }
      const card_groups = []
      let year_cache
      let card_group
      timeline_cards.forEach((card) => {
        const card_data = cards_data[card.id.slice(-1)]
        if (cardfilter.includes(card_data)) {
          const slice = card_data.date.slice(-4)
          if (year_cache !== slice) {
            card_group = document.createElement('div')
            card_group.classList.add('card_group')
            card_groups.push(card_group)
            year_cache = slice
          }
          card_group.append(card)
        }
      })
      card_groups.forEach((card_group) => {
        timeline_wrapper.append(card_group)
      })
      PROTOCOL.scrollbar({ type: 'handle_scroll' })
      PROTOCOL.setScroll({
        filter: 'YEAR',
        value: String(new Date(cardfilter[0].date_raw).getFullYear())
      })
    }
    async function toggle_active_state (message) {
      const { head, refs, type, data, meta } = message
      const { active_state } = data
      ;( active_state === 'active') ? el.style.display = 'none' : ''
    }
    async function toggle_month_filter (message) {
      if (month_wrapper.contains(month_filter_wrapper))
        month_wrapper.removeChild(month_filter_wrapper)
      else
        month_wrapper.append(month_filter_wrapper)
    }
    async function toggle_year_filter (message) {
      if (filter_wrapper.contains(year_filter_wrapper))
        filter_wrapper.removeChild(year_filter_wrapper)
      else
        filter_wrapper.append(year_filter_wrapper)
    }
  }
  async function updateCalendar () {
    let dates = []
    if (PROTOCOL.YEAR) cards_data.forEach(card_data => {
      if (card_data.date.includes(PROTOCOL.YEAR)) dates.push(card_data.date)
    })
    PROTOCOL.month_filter({
      head: { by: name, to: 'month_filter', mid: 0 },
      type: null,
      data: dates
    })
  }
}
function get_theme () {
  return`
    .main_wrapper {
      display: flex;
      flex-direction: column;
      container-type: inline-size;
      width: 100%;
      height: 100%;
      margin-bottom: 30px;

      * {
        box-sizing: border-box;
      }
      .filter_wrapper {
        display: flex;
        width: 100%;
        height: 100%;
        .month_wrapper {
          width: 100%;
          height: 100%;
          overflow: hidden;
          border: 1px solid var(--primary_color);
          .scrollbar_wrapper {
            display: flex;
            width: 100%;
            height: 100%;
            .timeline_wrapper {
              --s: 20px; /* control the size */
              --_g: var(--bg_color) /* first color */ 0 25%, #0000 0 50%;
              background:
                repeating-conic-gradient(at 66% 66%,var(--_g)),
                repeating-conic-gradient(at 33% 33%,var(--_g)),
                var(--primary_color);  /* second color */ 
              background-size: var(--s) var(--s);  
              border :1px solid var(--primary_color);
              display: flex;
              flex-direction: column;
              width: 100%;
              height: 400px;
              overflow: scroll;
              gap: 20px;
              scrollbar-width: none; /* For Firefox */
              .card_group {
                width: 100%;
                padding: 0px;
                display: grid;
                gap: 20px;
                grid-template-columns: 12fr;
              }
              &::-webkit-scrollbar {
                display: none;
              }
            }
          }
        }
      }
    }
    @container(min-width: 768px) {
      .main_wrapper {
        .filter_wrapper {
          .month_wrapper {
            .scrollbar_wrapper {
              .timeline_wrapper {
                .card_group {
                  grid-template-columns: repeat(2, 6fr);
                }
              }
            }
          }
        }
      }
    }
    @container(min-width: 1200px) {
      .main_wrapper {
        .filter_wrapper {
          .month_wrapper {
            .scrollbar_wrapper {
              .timeline_wrapper {
                .card_group {
                  grid-template-columns: repeat(3, 4fr);
                }
              }
            }
          }
        }
      }
    }
  `
}