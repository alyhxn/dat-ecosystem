const window_bar = require('window-bar')
const timeline_card = require('timeline-card')
const timeline_filter = require('timeline-filter')
const year_filter = require('year-filter')
const month_filter = require('month-filter')
const scrollbar = require('scrollbar')
/******************************************************************************
  APP TIMELINE COMPONENT
******************************************************************************/
// ----------------------------------------
// MODULE STATE & ID
var count = 0
const [cwd, dir] = [process.cwd(), __filename].map(x => new URL(x, 'file://').href)
const ID = dir.slice(cwd.length)
const STATE = { ids: {}, net: {} } // all state of component module
// ----------------------------------------
const sheet = new CSSStyleSheet
sheet.replaceSync(get_theme())
const default_opts = { }
const shopts = { mode: 'closed' }
// ----------------------------------------
module.exports = app_timeline
// ----------------------------------------
function app_timeline (opts = default_opts, protocol) {
  // ----------------------------------------
  // RESOURCE POOL (can't be serialized)
  // ----------------------------------------
  const ro = new ResizeObserver(entries => {
    console.log('ResizeObserver:terminal:resize')
    const scroll_channel = state.net[state.aka.scrollbar]
    scroll_channel.send({
      head: [id, scroll_channel.send.id, scroll_channel.mid++],
      refs: { },
      type: 'handle_scroll',
    })
  })
  // ----------------------------------------
  // ID + JSON STATE
  // ----------------------------------------
  const id = `${ID}:${count++}` // assigns their own name
  const status = {}
  const state = STATE.ids[id] = { id, status, wait: {}, net: {}, aka: {} } // all state of component instance
  const cache = resources({})
  status.YEAR = ''
  status.MONTH = ''
  status.DATE = ''
  status.cards = []
  status.years = []
  let dates = []
  let visitor = ''
  let cardfilter
  // ----------------------------------------
  // Local Storage
  // ----------------------------------------
  if (localStorage.getItem('visitedBefore')) {
    visitor = 'old'
  } else {
    visitor = 'new'
    localStorage.setItem('visitedBefore', 'true')
  }
  // ----------------------------------------
  // OPTS
  // ----------------------------------------
  const { data } = opts
  // Assigning all the icons
  const { img_src: {
      icon_folder_solid= `${prefix}/icon_folder_solid.svg`,
  } } = data
  const cards_data = [
    {
      title: 'dat - brainstorming an idea', 
      date: 'October 12, 2011', 
      time: '', 
      link: 'https://rufuspollock.com/2011/10/17/weekly-update-rufus-pollock-2/', 
      desc: 'Max Ogden chats with Rufus Pollock about a changes protocol for data to allow diffing/merging and supports micro-schemas at the Open Government Data Camp', 
      tags: ['article'], 
      data, 
      active_state: 'ACTIVE'
    },{
      title: 'Knight Foundation Funding ($50.000)',
      date: 'June 23, 2013',
      time: '',
      link: 'https://web.archive.org/web/20130810075932/http://www.knightfoundation.org/grants/201346305/',
      desc: 'Brings dat (as http://dat-data.com) from an idea to the pre-alpha stage',
      tags: ['grant'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'dat - initial readme',
      date: 'June 27, 2013',
      time: '',
      link: 'https://github.com/dat-ecosystem/dat/tree/464679267049899eafa345125a0f2212f91be456',
      desc: 'Dat is created by Max Ogden in 2013 to standardize the way data analysts collaborate on the changes they make to data sets. Rufus Pollock from the Open Knowledge Foundation describes it as git (and github) for data',
      tags: ['milestone'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'dat-data website',
      date: 'October 12, 2023',
      time: '',
      link: 'https://dat-ecosystem-archive.github.io/dat-data.com/',
      desc: 'First website is released',
      tags: ['website'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'twitter account',
      date: 'November 01, 2013',
      time: '',
      link: 'https://twitter.com/dat_ecosystem',
      desc: '@dat_protocol twitter account is created (later renamed to @dat_ecosystem)',
      tags: ['asset'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'introducing dat',
      date: 'November 11, 2013',
      time: '',
      link: 'https://www.youtube.com/watch?v=FX7qSwz3SCk',
      desc: 'Max Ogden presents Dat at the Strata Conference in London',
      tags: ['talk'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'Alfred P. Sloan Foundation Funding ($260.000)',
      date: 'April 02, 2014',
      time: '',
      link: 'https://usopendata.org/2014/04/02/dat/',
      desc: 'Helps dat to become an US ODI (Open Data Institute) project',
      tags: ['Open Data Institute'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'peermaps',
      date: 'May 22, 2014',
      time: '',
      link: 'https://peermaps.org/',
      desc: 'Peermaps is born (peer to peer cartography)',
      tags: ['project'],
      data,
      active_state: 'PAUSED'
    },{
      title: 'dat - alpha',
      date: 'August 19, 2014',
      time: '',
      link: 'https://usopendata.org/2014/08/19/dat-alpha/',
      desc: 'Dat Alpha version is released',
      tags: ['milestone'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'Alfred P. Sloan',
      date: 'April 03, 2015',
      time: '',
      link: 'https://donations.vipulnaik.com/donor.php?donor=Sloan+Foundation',
      desc: 'Alfred P. Sloan Foundation Funding ($640.000)',
      tags: ['grant'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'dat - beta',
      date: 'July 29, 2015',
      time: '',
      link: 'https://usopendata.org/2015/07/29/dat-beta/',
      desc: 'Dat Beta version is released -  the version focused on tabular datasets. It turns out to be too complex for typical use cases',
      tags: ['milestone'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'designing dat 1.0',
      date: 'December 04, 2015',
      time: '',
      link: 'https://vimeo.com/147914258',
      desc: 'Designing dat 1.0, rOpenSci Community Call v8',
      tags: ['presentation'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'hyperdrive release',
      date: 'December 02, 2015',
      time: '',
      link: 'https://github.com/hypercore-protocol/hyperdrive/releases/tag/v1.0.1',
      desc: 'Hyperdrive v1.0.0 is released',
      tags: ['milestone'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'hypercore release',
      date: 'December 20, 2015',
      time: '',
      link: 'https://github.com/hypercore-protocol/hypercore/releases/tag/v1.0.0',
      desc: 'Hypercore v1.0.0 is released',
      tags: ['milestone'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'alpha testing',
      date: 'December 21, 2015',
      time: '',
      link: '/',
      desc: 'Alpha testing with pilot projects in science, including Sloan Digital Sky Survey (Astronomy), iRNA-Seq (Bioinformatics – RNA), and Bionode (Bioinformatics – DNA)Hypercore v1.0.0 is released',
      tags: ['milestone'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'dat 1.0.',
      date: 'February 01, 2016',
      time: '',
      link: 'https://blog.dat-ecosystem.org/dat-1-0-is-ready/',
      desc: 'Dat 1.0. is ready',
      tags: ['milestone'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'Knight Foundation Funding ($420.000)',
      date: 'February 01, 2016',
      time: '',
      link: 'https://blog.dat-ecosystem.org/announcing-publicbits-org/',
      desc: 'Knight Foundation Grant ($420.000) for Publicbeats project',
      tags: ['grant'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'Code for Science and Society',
      date: 'September 01, 2016',
      time: '',
      link: 'https://codeforscience.org/about/',
      desc: 'Code for Science and Society is founded - to support the Dat Project as a fiscal sponsor bundled with strategic project support',
      tags: ['project'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'first meetups',
      date: 'December 01, 2016',
      time: '',
      link: 'https://blog.datproject.org/tag/community/',
      desc: 'The first meetups for ‘Coding for Science & Society’ are held in Berlin, Oakland, and Portland; organized by the Dat team',
      tags: ['community'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'cli tool',
      date: 'January 09, 2017',
      time: '',
      link: 'https://blog.dat-ecosystem.org/preview-the-new-dat-cli/',
      desc: 'New Dat CLI is released',
      tags: ['milestone'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'beaker browser',
      date: 'February 07, 2017',
      time: '',
      link: 'https://www.electronjs.org/blog/beaker-browser',
      desc: 'Beaker browser pre-release',
      tags: ['project'],
      data,
      active_state: 'INACTIVE'
    },{
      title: 'dat desktop',
      date: 'February 12, 2017',
      time: '',
      link: 'https://blog.dat-ecosystem.org/dat-desktop-is-here/',
      desc: 'Dat desktop is released',
      tags: ['milestone'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'dat 2.0',
      date: 'June 01, 2017',
      time: '',
      link: 'https://blog.dat-ecosystem.org/dat-sleep-release/',
      desc: 'Dat 2.0 is released',
      tags: ['milestone'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'dat whitepaper',
      date: 'June 01, 2017',
      time: '',
      link: 'https://github.com/dat-ecosystem-archive/whitepaper/blob/master/dat-paper.pdf',
      desc: 'Dat whitepaper is released',
      tags: ['whitepaper'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'Moore Foundation Grant ($110.000)',
      date: 'September 14, 2017',
      time: '',
      link: 'https://blog.dat-ecosystem.org/dat-in-the-lab/',
      desc: 'Moore Foundation grant for collaboration of dat and California Digital Library (CDL)',
      tags: ['grant'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'organizational changes',
      date: 'December 20, 2017',
      time: '',
      link: 'https://blog.datproject.org/2017/12/20/organization-changes-dat-css/',
      desc: 'Organizational Changes for Dat and Code for Science & Society',
      tags: ['organization'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'arso',
      date: 'March 02, 2018',
      time: '',
      link: 'https://arso.xyz/',
      desc: 'arso joins the ecosystem',
      tags: ['project'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'multifeed',
      date: 'April 12, 2018',
      time: '',
      link: 'https://github.com/kappa-db/multifeed/releases/tag/v1.0.0',
      desc: 'Multi-writer hypercore (multifeed) is released',
      tags: ['project'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'Beaker browser and the Dat protocol analysis',
      date: 'May 01, 2018',
      time: '',
      link: 'https://bernsteinbear.com/dat-paper/',
      desc: 'Beaker browser and the Dat protocol: An analysis for COMP 117: Internet-scale Distributed Systems is released',
      tags: ['scientific article'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'kappa core',
      date: 'May 13, 2018',
      time: '',
      link: 'https://github.com/kappa-db/kappa-core/releases/tag/v1.0.0',
      desc: 'Kappa Core 1.0 is released (minimal append only DB)',
      tags: ['project'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'cabal',
      date: 'May 13, 2018',
      time: '',
      link: 'https://github.com/cabal-club/cabal-core/releases/tag/v1.0.0',
      desc: 'Cabal core 1.0 is release',
      tags: ['project'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'Mozila Open Source Support Grant ($34,000)',
      date: 'September 05, 2018',
      time: '',
      link: 'https://blog.dat-ecosystem.org/moss-2019-summary/',
      desc: 'Dat Project Receives Mozilla Open Source Support Grant',
      tags: ['grant'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'dat open collective',
      date: 'October 05, 2018',
      time: '',
      link: 'https://opencollective.com/dat',
      desc: 'Dat Open Collective page is set up for recurring donations',
      tags: ['donations'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'how dat works',
      date: 'November 01, 2018',
      time: '',
      link: 'https://dat-ecosystem-archive.github.io/how-dat-works/',
      desc: 'How dat works visualization project is started',
      tags: ['asset'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'Handshake Grant ($100.000)',
      date: 'December 01, 2018',
      time: '',
      link: 'https://blog.dat-ecosystem.org/dat-receives-two-new-grants/',
      desc: 'Handshake Grant is received',
      tags: ['grant'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'Samsung NEXT Stack Zero Grant ($63.000)',
      date: 'December 02, 2018',
      time: '',
      link: 'https://blog.dat-ecosystem.org/dat-receives-two-new-grants/',
      desc: 'Samsung NEXT Stack Zero grant is received',
      tags: ['grant'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'dat hack unconference',
      date: 'May 19, 2019',
      time: '',
      link: 'https://events.dat.foundation/2019/',
      desc: 'Dat Hack Unconference in Berlin',
      tags: ['event'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'Wireline Donation ($50,000)',
      date: 'June 01, 2019',
      time: '',
      link: 'https://github.com/datproject/organization#2019',
      desc: 'Dat Project receives donation from Wireline',
      tags: ['donation'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'dat consortium',
      date: 'December 01, 2019',
      time: '',
      link: 'https://hackmd.io/@T6Wf5EsOQKe-6wyPjJPtuw/Hycn0F63r/%2FHbu0ffkwQS6KIO_97fH-Mw',
      desc: 'Dat consortium is formed',
      tags: ['organization'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'ara',
      date: 'December 01, 2019',
      time: '',
      link: 'https://ara.one/',
      desc: 'Ara joins the ecosystem',
      tags: ['project'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'consento',
      date: 'December 01, 2019',
      time: '',
      link: 'https://consento.org/',
      desc: 'Consento joins the ecosystem',
      tags: ['project'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'datdot',
      date: 'December 01, 2019',
      time: '',
      link: 'https://datdot.org/',
      desc: 'DatDot joins the ecosystem',
      tags: ['project'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'decentlabs',
      date: 'December 01, 2019',
      time: '',
      link: 'https://decentlabs.se/',
      desc: 'Decentlabs joins the ecosystem',
      tags: ['project'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'geut',
      date: 'December 01, 2019',
      time: '',
      link: 'https://www.geutstudio.com/',
      desc: 'Geut joins the ecosystem',
      tags: ['project'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'digital democracy',
      date: 'December 01, 2019',
      time: '',
      link: 'https://www.digital-democracy.org/',
      desc: 'Digital Democracy joins the ecosystem',
      tags: ['project'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'arso - sonar release',
      date: 'December 17, 2019',
      time: '',
      link: 'https://arso.xyz/blog/2019-12-17-introducing-sonar',
      desc: 'Arso introduces Sonar',
      tags: ['project'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'Hypercore protocol graduates from Dat Ecosystem',
      date: 'May 15, 2020',
      time: '',
      link: 'https://blog.dat-ecosystem.org/dat-protocol-renamed-hypercore-protocol/',
      desc: 'Dat protocol is renamed to Hypercore protocol',
      tags: ['project'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'NLnet grant ($50.000)',
      date: 'July 01, 2020',
      time: '',
      link: 'https://github.com/datproject/organization#2020',
      desc: 'NLnet grant is recieved for a Rust port',
      tags: ['grant'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'agregore',
      date: 'June 19, 2020',
      time: '',
      link: 'https://github.com/AgregoreWeb/agregore-browser/releases/tag/v1.0.1-0',
      desc: 'Agregore browser is pre-released',
      tags: ['project'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'dat conference',
      date: 'July 30, 2020',
      time: '',
      link: 'https://www.youtube.com/channel/UCbLY5Qg3t3OJbxZZUioqMOQ',
      desc: 'Dat online conference is organized',
      tags: ['event'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'agregore',
      date: 'October 14, 2020',
      time: '',
      link: 'https://agregore.mauve.moe/',
      desc: 'Agregore joins the ecosystem',
      tags: ['project'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'gateway browser',
      date: 'January 11, 2020',
      time: '',
      link: 'https://gitlab.com/gateway-browser/gateway',
      desc: 'Gateway browser joins the ecosystem',
      tags: ['project'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'hyperbee',
      date: 'December 03, 2020',
      time: '',
      link: 'https://github.com/hypercore-protocol/hyperbee/releases/tag/v1.0.0',
      desc: 'Hyperbee 1.0 is released',
      tags: ['project'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'earthstar',
      date: 'January 10, 2021',
      time: '',
      link: 'https://github.com/earthstar-project/earthstar',
      desc: 'Earthstar joins the ecosystem',
      tags: ['project'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'dat manifesto',
      date: 'March 09, 2021',
      time: '',
      link: 'https://github.com/dat-ecosystem/organization/blob/main/MANIFESTO.md',
      desc: 'Dat consortium forms Dat Ecosystem and consoritum members sign a manifesto',
      tags: ['organization'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'Code for Science and Society grant ($20.000)',
      date: 'December 21, 2021',
      time: '',
      link: 'https://blog.dat-ecosystem.org/dat-ecosystem-relaunch/',
      desc: 'Archiving and ecosystem launch grant',
      tags: ['grant'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'socket supply',
      date: 'April 15, 2022',
      time: '',
      link: 'https://socketsupply.co/',
      desc: 'Socket Supply joins the ecosystem',
      tags: ['project'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'hyperswarm',
      date: 'July 02, 2021',
      time: '',
      link: 'https://github.com/hyperswarm/hyperswarm/releases/tag/v3.0.0-beta2',
      desc: 'Hyperswarm v3.0.0-beta is released',
      tags: ['project'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'autobase',
      date: 'July 02, 2021',
      time: '',
      link: 'https://github.com/hypercore-protocol/autobase/releases/tag/v1.0.0-alpha.0',
      desc: 'Autobase v3.0.0-beta is released',
      tags: ['project'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'dat ecosystem archive',
      date: 'August 01, 2021',
      time: '',
      link: 'https://github.com/dat-ecosystem-archive',
      desc: 'Dat ecosystem archive is created to archive all the historic repositories',
      tags: ['organization'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'geut - sher',
      date: 'October 08, 2021',
      time: '',
      link: 'https://sher.geutstudio.com/',
      desc: 'Geut studio introduces new project Sher',
      tags: ['organization'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'ahau',
      date: 'April 30, 2022',
      time: '',
      link: 'https://ahau.io/',
      desc: 'ahau joins the ecosystem',
      tags: ['project'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'keet',
      date: 'July 25, 2022',
      time: '',
      link: 'https://keet.io/',
      desc: 'hypercore protocol team releases Keet',
      tags: ['project'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'dcent reads',
      date: 'August 20, 2022',
      time: '',
      link: 'https://www.dcent-reads.org/#/read',
      desc: 'Dcent Reads, a platform for decentralised publishing joins the ecosystem',
      tags: ['project'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'wizard amigos',
      date: 'August 27, 2022',
      time: '',
      link: 'https://wizardamigos.com',
      desc: 'wizard amigos join the ecosystem',
      tags: ['project'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'lumeweb',
      date: 'September 4, 2022',
      time: '',
      link: 'https://lumeweb.com/',
      desc: 'lumeweb join the ecosystem',
      tags: ['project'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'wizard amigos code camp',
      date: 'September 26, 2022',
      time: '',
      link: 'https://wizardamigos.com/codecamp2022/',
      desc: 'wizard amigos code camp is organized in Wales',
      tags: ['event'],
      data,
      active_state: 'ACTIVE'
    }, {
      title: 'HOP',
      date: 'November 23, 2022',
      time: '',
      link: 'https://www.healthscience.network/',
      desc: 'HOP (health oracle protocol) joins the ecosystem',
      tags: ['project'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'dat ecosystem visualized',
      date: 'January 7, 2023',
      time: '',
      link: 'https://micahscopes.github.io/webscape-wanderer/',
      desc: 'webscape wanderer visualizer engine is created to visualize dat ecosystem',
      tags: ['presentation'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'webscape wanderer',
      date: 'January 8, 2023',
      time: '',
      link: 'https://github.com/micahscopes/webscape-wanderer/',
      desc: 'webscape wanderer joins the ecosystem',
      tags: ['project'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'interview series',
      date: 'May 3, 2023',
      time: '',
      link: 'https://blog.dat-ecosystem.org/staying-connected/',
      desc: 'video interviews launch',
      tags: ['presentation'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'dxos',
      date: 'May 15, 2023',
      time: '',
      link: 'https://dxos.org/',
      desc: 'dxos joins the ecosystem',
      tags: ['project'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'hyper-nostr',
      date: 'July 5, 2023',
      time: '',
      link: 'https://github.com/Ruulul/hyper-nostr',
      desc: 'hypercore-nostr relay is published and project joins the ecosystem',
      tags: ['project'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'demo & AMA sessions',
      date: 'August 27, 2023',
      time: '',
      link: 'https://blog.dat-ecosystem.org/tags/demo/',
      desc: 'demo sessions and AMA commm comm calls launch',
      tags: ['presentation'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'wizard amigos code camp',
      date: 'October 1, 2023',
      time: '',
      link: 'https://wizardamigos.com/codecamp2023/',
      desc: 'wizard amigos code camp is organized in Portugal',
      tags: ['event'],
      data,
      active_state: 'ACTIVE'
    },{
      title: 'new dat ecosystem web page is released',
      date: 'January 11, 2024',
      time: '',
      link: 'https://dat-ecosystem.org',
      desc: 'Dat ecosystem releases new web page',
      tags: ['organization'],
      data,
      active_state: 'ACTIVE'
    }
  ].map(card => {
      const date = new Date(card.date + ' ' + convert_time_format(card.time))
      if(!status.years.includes(date.getFullYear()))
        status.years.push(date.getFullYear())
      card.date_raw = date.getTime()
      dates.push(card.date_raw)
      return card
    }).sort(function (a, b) {
      const dateA = new Date(a.date_raw)
      const dateB = new Date(b.date_raw)
      // Compare years in ascending/descending order
      if (dateA.getFullYear() !== dateB.getFullYear()) {
        return dateA.getFullYear() - dateB.getFullYear()
        // return visitor === 'new' ? dateA.getFullYear() - dateB.getFullYear() : dateB.getFullYear() - dateA.getFullYear()
      }
      // If years are the same, compare months in descending order
      return dateA.getMonth() - dateB.getMonth()
    })
  cardfilter = [...cards_data]
  const tags = new Set(cards_data.flatMap(card => card.tags))
  const card_groups = []
  let year_cache, card_group, prev_year
  status.YEAR = new Date(cards_data[0].date_raw).getFullYear()
  // ----------------------------------------
  // PROTOCOL
  // ----------------------------------------
  const PROTOCOL = {}
  const on = {}
  const channel = use_protocol('app_timeline')({ protocol, state, on })
  // ----------------------------------------
  // TEMPLATE
  // ----------------------------------------
  const el = document.createElement('div')
  const shadow = el.attachShadow(shopts)
  shadow.adoptedStyleSheets = [sheet]
  shadow.innerHTML = `
  <div class="timeline_section">
    <div class="windowbar"></div>
    <div class="main_wrapper">
      <div class="filter_wrapper">
          <div class="month_wrapper">
            <div class="timeline_wrapper">
            </div>
            <div class="empty_wrapper">
              <div>
                No match found
              <div>
            </div>
          </div>
      </div>
    </div>
  </div>`
  const main_wrapper = shadow.querySelector('.main_wrapper')
  const timeline_wrapper = shadow.querySelector('.timeline_wrapper')
  const filter_wrapper = shadow.querySelector('.filter_wrapper')
  const month_wrapper = shadow.querySelector('.month_wrapper')
  const empty_wrapper = shadow.querySelector('.empty_wrapper')
  // ----------------------------------------
  const windowbar_shadow = shadow.querySelector('.windowbar').attachShadow(shopts)
  // ----------------------------------------
  // ELEMENTS
  // ----------------------------------------
  { // windowbar
    const on = { 'toggle_active_state': toggle_active_state }
    const protocol = use_protocol('windowbar')({ state, on })
    const opts = {
      name: 'TIMELINE', 
      src: icon_folder_solid,
      data: data
    }
    const element = window_bar(opts, protocol)
    windowbar_shadow.append(element)
    async function toggle_active_state (message) {
      const { active_state } = message.data
      if (active_state === 'active') el.style.display = 'none'
    }
  }
  var timeline_cards
  { // timeline cards
    const on = {}
    function make_card (card_data, i) {
      const protocol = use_protocol(`card_${i}`)({ state, on })
      const opts = card_data
      const element = shadowfy()(timeline_card(opts, protocol))          
      const slice = card_data.date.slice(-4)
      if (year_cache !== slice) {
        card_group = document.createElement('div')
        card_group.classList.add('card_group')
        card_groups.push(card_group)
        year_cache = slice
      }
      card_group.append(element)
      element.idx = i
      return element
    }
    timeline_cards = cards_data.map(make_card)
    timeline_wrapper.append(...card_groups)
    timeline_wrapper.onscroll = onscroll
  }
  { // timeline filter
    const on = {
      'toggle_month_filter': toggle_month_filter,
      'toggle_year_filter': toggle_year_filter,
      'value': on_value,
      'set_filter': setFilter
    }
    const protocol = use_protocol('timeline_filter')({ state, on })
    const opts = {
      data, tags: Array.from(tags),
      latest_date: cards_data[0].date_raw
    }
    const element = shadowfy()(timeline_filter(opts, protocol))
    main_wrapper.append(element)
    function on_value (message) { setFilter(message.data) }
    async function toggle_month_filter (message) {
      if (month_wrapper.contains(month_filter_wrapper)) {
        month_wrapper.removeChild(month_filter_wrapper)
        timeline_wrapper.style.height = '500px'
      } else {
        month_wrapper.append(month_filter_wrapper)
        timeline_wrapper.style.height = '333px'
      }
    }
    async function toggle_year_filter (message) {
      if (filter_wrapper.contains(year_filter_wrapper)) {
        filter_wrapper.removeChild(year_filter_wrapper)
      } else filter_wrapper.append(year_filter_wrapper)
    }
  }
  var year_filter_wrapper
  { // year filter
    const on = { 'set_scroll': on_set_scroll }
    const protocol =  use_protocol('year_filter')({ state, on })
    
    const opts = {
      data, latest_date: Math.max(...dates), oldest_date: Math.min(...dates), visitor
    }
    year_filter_wrapper = shadowfy()(year_filter(opts, protocol))
    function on_set_scroll ({ data }) {
      set_scroll(data)
      updateCalendar()
    }
  }
  year_filter_wrapper.classList.add('year_filter_wrapper')
  var month_filter_wrapper
  { // month filter
    const on = { 'set_scroll': on_set_scroll, 'set_filter': setFilter }
    const protocol = use_protocol('month_filter')({ state, on })
    const opts = { data }
    month_filter_wrapper = shadowfy()(month_filter(opts, protocol))
    month_filter_wrapper.classList.add('month_filter_wrapper')
    function on_set_scroll ({ data }) {
      set_scroll(data)
      updateCalendar()
    }
  }
  { // scrollbar
    const on = { 'set_scroll': on_set_scroll, status: onstatus }
    const protocol = use_protocol('scrollbar')({ state, on })
    opts.data.img_src.icon_arrow_start = opts.data.img_src.icon_arrow_up
    opts.data.img_src.icon_arrow_end = opts.data.img_src.icon_arrow_down
    const scroll_opts = { data }
    const element = shadowfy()(scrollbar(scroll_opts, protocol))
    filter_wrapper.append(element)

    const channel = state.net[state.aka.scrollbar]
    ro.observe(timeline_wrapper)
    function on_set_scroll (message) { setScrollTop(message.data) }
    function onstatus (message) {
      channel.send({
        head: [id, channel.send.id, channel.mid++],
        refs: { cause: message.head },
        type: 'update_size',
        data: {
          sh: timeline_wrapper.scrollHeight,
          ch: timeline_wrapper.clientHeight,
          st: timeline_wrapper.scrollTop
        }
      })
    }
  }
  // ----------------------------------------
  // INIT
  // ----------------------------------------
  updateCalendar()

  return el

  function onscroll (event) {
    const scroll_channel = state.net[state.aka.scrollbar]
    scroll_channel.send({
      head: [id, scroll_channel.send.id, scroll_channel.mid++],
      type: 'handle_scroll'
    })
    const parent_top = timeline_wrapper.getBoundingClientRect().top
    timeline_cards.some(card => {
      const { idx } = card
      const child_top = card.getBoundingClientRect().top
      if (child_top >= parent_top -100 && child_top < parent_top + 200) {
        const year = cards_data[idx].date.slice(-4)
        status.YEAR = year
        updateCalendar()
        const channel = state.net[state.aka.year_filter]
        channel.send({
          head: [id, channel.send.id, channel.mid++],
          type: 'update_year_filter',
          data: year
        })
        return true
      }
    })
    const channel = state.net[state.aka.timeline_filter]
    channel.send({
      head: [id, channel.send.id, channel.mid++],
      type: 'update_timeline_filter',
      data: { month: status.MONTH , year: status.YEAR }
    })
  }
  function convert_time_format (time) {
    let temp = time.slice(0, 2)
    if (time.includes('PM')) { temp = parseInt(temp) + 12 }
    return temp + time.slice(2, -2)
  }
  async function set_scroll (data) {
    if (data.filter === 'YEAR'){
      if (status.years.includes(Number(data.value))){
        empty_wrapper.classList.remove('active')
        timeline_wrapper.classList.remove('hide')
      }
      else {
        empty_wrapper.classList.add('active')
        timeline_wrapper.classList.add('hide')
        status.YEAR = data.value
        updateCalendar()
        return
      }
    }
    if (data.value){
      status[data.filter] = data.value
      let check = true
      timeline_cards.some(card => {
        const { idx } = card
        const card_data = cards_data[idx]
        if(cardfilter.includes(card_data)){
          const card_date = card_data.date

          if (card_date.includes(data.value) && card_date.includes(status.YEAR)) {
            if(check && status.cards){
              setScrollTop(card.getBoundingClientRect().top - timeline_wrapper.getBoundingClientRect().top + timeline_wrapper.scrollTop)

              check = false
              status.cards.forEach(status_card => {
                status_card.classList.remove('active')
              })
              if(status.cards[0] === card){
                status.cards = []
                return true
              }
              status.cards = []
            }
            if(data.filter === 'DATE'){
              card.classList.add('active')
              status.cards.push(card)
            }
          }
          else if(!check){
            return true
          }
        }
      })
      const timeline_channel = state.net[state.aka.timeline_filter]
      timeline_channel.send({
        head: [id, timeline_channel.send.id, timeline_channel.mid++],
        type: 'update_timeline_filter',
        data: { month: status.MONTH , year: status.YEAR }
      })
      const year_channel = state.net[state.aka.year_filter]
      year_channel.send({
        head: [id, year_channel.send.id, year_channel.mid++],
        type: 'update_year_filter',
        data: status.YEAR
      })
    }
    else if(status.cards){
      status.cards.forEach(status_card => {
        status_card.classList.remove('active')
      })
      status.cards = []
    }
  }
  async function setScrollTop (value) {
    timeline_wrapper.scrollTop = value
  }
  async function setFilter (data) {
    status[data.filter] = data.value
    timeline_wrapper.innerHTML = ''
    cardfilter = [...cards_data]
    if (status.SEARCH) cardfilter = cardfilter.filter((card_data) => {
      return card_data.title.toLowerCase().match(status.SEARCH.toLowerCase())
    })
    if (status.STATUS && status.STATUS !== 'ALL') cardfilter = cardfilter.filter((card_data) => {
      return card_data.active_state === status.STATUS && card_data
    })
    if (status.TAGS && status.TAGS !== 'ALL') {
      cardfilter = cardfilter.filter((card_data) => {
        return card_data.tags.includes(status.TAGS) && card_data
      })
    }

    status.years = []
    const card_groups = []
    let year_cache
    let card_group
    
    timeline_cards.forEach(card => {
      const { idx } = card
      const card_data = cards_data[idx]
      if (cardfilter.includes(card_data)) {
        const date = new Date(card_data.date)
        if(!status.years.includes(date.getFullYear()))
          status.years.push(date.getFullYear())
        const slice = card_data.date.slice(-4)
        if (year_cache !== slice) {
          card_group = document.createElement('div')
          card_group.classList.add('card_group')
          card_groups.push(card_group)
          year_cache = slice
        }
        card_group.append(card)
      }
    })
    card_groups.forEach((card_group) => {
      timeline_wrapper.append(card_group)
    })
    if(cardfilter.length === 0){
      empty_wrapper.classList.add('active')
    }
    else{
      empty_wrapper.classList.remove('active')
    }
    const channel = state.net[state.aka.scrollbar]
    channel.send({
      head: [id, channel.send.id, channel.mid++],
      type: 'handle_scroll'
    })
    if (!cardfilter[0]) return
    set_scroll({
      filter: 'YEAR',
      value: String(new Date(cardfilter[0].date_raw).getFullYear())
    })
    updateCalendar()
  }
  async function updateCalendar () {
    let dates = []
    if (status.YEAR) cardfilter.forEach(card_data => {
      if (card_data.date.includes(status.YEAR)) dates.push(card_data.date)
    })
    const channel = state.net[state.aka.month_filter]
    if(prev_year !== String(status.YEAR)){
      channel.send({
        head: [id, channel.send.id, channel.mid++],
        type: 'update_calendar',
        data: {dates, year: Number(status.YEAR)}
      })
      prev_year = String(status.YEAR).slice(0)
      if(status.cards){
        status.cards.forEach(status_card => {
          status_card.classList.remove('active')
        })
        status.cards = []
      }
    }
    
  }
}
function get_theme () {
  return`
    .timeline_section {
      display: flex;
      flex-direction: column;
    }
    .main_wrapper {
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      container-type: inline-size;
      width: 100%;
      height: 100%;
      margin-bottom: 30px;
    }
    .main_wrapper * {
      box-sizing: border-box;
    }
    .main_wrapper .filter_wrapper {
      display: flex;
      width: 100%;
      height: 100%;
      border :1px solid var(--primary_color);
      }
    .main_wrapper .filter_wrapper .month_wrapper {
      width: 100%;
      height: 100%;
      overflow: hidden;
      border: 1px solid var(--primary_color);
      position: relative;
    }

    .main_wrapper .filter_wrapper .timeline_wrapper {
      --s: 15px; /* control the size */
      --_g: var(--bg_color_2) /* first color */ 0 25%, #0000 0 50%;
      background:
        repeating-conic-gradient(at 33% 33%,var(--_g)),
        repeating-conic-gradient(at 66% 66%,var(--_g)),
        var(--bg_color_3);  /* second color */  
      background-size: var(--s) var(--s);
      border :1px solid var(--primary_color);
      display: flex;
      flex-direction: column;
      width: 100%;
      height: 500px;
      overflow: scroll;
      gap: 20px;
      scrollbar-width: none; /* For Firefox */
    }
    .main_wrapper .filter_wrapper .timeline_wrapper.hide > div {
      display: none;
    }
    .main_wrapper .filter_wrapper .empty_wrapper {
      display: none;
      position: absolute;
      width: 100%;
      height: 100%;
      justify-content: center;
      align-items: center;
      top: 0;
    }
    .main_wrapper .filter_wrapper .empty_wrapper > div {
      background-color: white;
    }
    .main_wrapper .filter_wrapper .empty_wrapper.active {
      display: flex;
    }
    .main_wrapper .filter_wrapper .timeline_wrapper .card_group {
      width: 100%;
      padding: 0px;
      display: grid;
      gap: 20px;
      grid-template-columns: 12fr;
    }
    .main_wrapper .filter_wrapper .timeline_wrapper .card_group > .active{
      border: 4px solid var(--ac-2);
    }
    .main_wrapper .filter_wrapper .timeline_wrapper::-webkit-scrollbar {
      display: none;
    }
    .main_wrapper .filter_wrapper .year_filter_wrapper{
      --s: 15px; /* control the size */
      --_g: var(--bg_color_2) /* first color */ 0 25%, #0000 0 50%;
      background:
        repeating-conic-gradient(at 33% 33%,var(--_g)),
        repeating-conic-gradient(at 66% 66%,var(--_g)),
        var(--bg_color_3);  /* second color */  
      background-size: var(--s) var(--s);  
      border :1px solid var(--primary_color);
    }
    .month_filter_wrapper{
      --s: 15px; /* control the size */
      --_g: var(--bg_color_2) /* first color */ 0 25%, #0000 0 50%;
      background:
        repeating-conic-gradient(at 33% 33%,var(--_g)),
        repeating-conic-gradient(at 66% 66%,var(--_g)),
        var(--bg_color_3);  /* second color */  
      background-size: var(--s) var(--s);  
      border: 1px solid var(--primary_color);
    }
    @container(min-width: 400px) {
      .main_wrapper .filter_wrapper .timeline_wrapper .card_group:last-child{
        margin-bottom: 300px;
      }
    }
    @container(min-width: 768px) {
      .main_wrapper .filter_wrapper .timeline_wrapper .card_group {
        grid-template-columns: repeat(2, 6fr);
      }
    }
    @container(min-width: 1200px) {
      .main_wrapper .filter_wrapper .timeline_wrapper .card_group {
        grid-template-columns: repeat(3, 4fr);
      }
    }
  `
}
// ----------------------------------------------------------------------------
function shadowfy (props = {}, sheets = []) {
  return element => {
    const el = Object.assign(document.createElement('div'), { ...props })
    const sh = el.attachShadow(shopts)
    sh.adoptedStyleSheets = sheets
    sh.append(element)
    return el
  }
}
function use_protocol (petname) {
  return ({ protocol, state, on = { } }) => {
    if (petname in state.aka) throw new Error('petname already initialized')
    const { id } = state
    const invalid = on[''] || (message => console.error('invalid type', message))
    if (protocol) return handshake(protocol(Object.assign(listen, { id })))
    else return handshake
    // ----------------------------------------
    // @TODO: how to disconnect channel
    // ----------------------------------------
    function handshake (send) {
      state.aka[petname] = send.id
      const channel = state.net[send.id] = { petname, mid: 0, send, on }
      return protocol ? channel : Object.assign(listen, { id })
    }
    function listen (message) {
      const [from] = message.head
      const by = state.aka[petname]
      if (from !== by) return invalid(message) // @TODO: maybe forward
      console.log(`[${id}]:${petname}>`, message)
      const { on } = state.net[by]
      const action = on[message.type] || invalid
      action(message)
    }
  }
}
// ----------------------------------------------------------------------------
function resources (pool) {
  var num = 0
  return factory => {
    const prefix = num++
    const get = name => {
      const id = prefix + name
      if (pool[id]) return pool[id]
      const type = factory[name]
      return pool[id] = type()
    }
    return Object.assign(get, factory)
  }
}